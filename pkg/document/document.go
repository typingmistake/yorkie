/*
 * Copyright 2020 The Yorkie Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package document provides JSON-like document(CRDT) implementation.
package document

import (
	"fmt"

	"github.com/yorkie-team/yorkie/pkg/document/change"
	"github.com/yorkie-team/yorkie/pkg/document/crdt"
	"github.com/yorkie-team/yorkie/pkg/document/json"
	"github.com/yorkie-team/yorkie/pkg/document/key"
	"github.com/yorkie-team/yorkie/pkg/document/presence"
	"github.com/yorkie-team/yorkie/pkg/document/time"
)

// Document represents a document accessible to the user.
//
// How document works:
// The operations are generated by the proxy while executing user's command on
// the clone. Then the operations will apply the changes into the base json
// root. This is to protect the base json from errors that may occur while user
// edit the document.
type Document struct {
	// doc is the original data of the actual document.
	doc *InternalDocument

	// clone is a copy of `doc` to be exposed to the user and is used to
	// protect `doc`.
	clone *crdt.Root
}

// New creates a new instance of Document.
func New(docKey key.Key, clientID string) *Document {
	return &Document{
		doc: NewInternalDocument(docKey, clientID),
	}
}

// InitPresence initializes the presence of the client who created this document.
func (d *Document) InitPresence(initialPresence presence.Presence) {
	d.doc.InitPresence(initialPresence)
}

// Update executes the given updater to update this document.
func (d *Document) Update(
	updater func(root *json.Object) error,
	msgAndArgs ...interface{},
) error {
	if d.doc.status == StatusRemoved {
		return ErrDocumentRemoved
	}

	if err := d.ensureClone(); err != nil {
		return err
	}

	if d.doc.changeContext != nil {
		if err := updater(json.NewObject(d.doc.changeContext, d.clone.Object())); err != nil {
			// drop clone because it is contaminated.
			d.clone = nil
			d.doc.changeContext = nil
			return err
		}
		return nil
	}

	d.doc.changeContext = change.NewContext(
		d.doc.changeID.Next(),
		messageFromMsgAndArgs(msgAndArgs...),
		d.clone,
	)

	if err := updater(json.NewObject(d.doc.changeContext, d.clone.Object())); err != nil {
		// drop clone because it is contaminated.
		d.clone = nil
		d.doc.changeContext = nil
		return err
	}

	if d.doc.changeContext == nil {
		return nil
	}
	if !d.doc.changeContext.HasChange() {
		d.doc.changeContext = nil
		return nil
	}

	c := d.doc.changeContext.ToChange()
	if err := c.Execute(d.doc.root); err != nil {
		return err
	}

	d.doc.localChanges = append(d.doc.localChanges, c)
	d.doc.changeID = d.doc.changeContext.ID()
	d.doc.changeContext = nil
	return nil
}

// UpdatePresence updates the presence of the client who created this document.
func (d *Document) UpdatePresence(k, v string) error {
	presenceInfo, err := d.doc.PresenceInfo(d.doc.myClientID)
	if err != nil {
		return err
	}
	presenceInfo.Clock++
	presenceInfo.Presence[k] = v

	if d.doc.changeContext != nil {
		d.doc.changeContext.SetPresenceInfo(presenceInfo.DeepCopy())
		return nil
	}

	d.doc.changeContext = change.NewContext(
		d.doc.changeID.Next(),
		"",
		d.clone,
	)
	d.doc.changeContext.SetPresenceInfo(presenceInfo.DeepCopy())
	c := d.doc.changeContext.ToChange()
	d.doc.localChanges = append(d.doc.localChanges, c)
	d.doc.changeID = d.doc.changeContext.ID()
	d.doc.changeContext = nil
	return nil
}

// Watch subscribes to PeerChangedEvent on this document.
func (d *Document) Watch() chan PeerChangedEvent {
	return d.doc.events
}

// ApplyChangePack applies the given change pack into this document.
func (d *Document) ApplyChangePack(pack *change.Pack) error {
	// 01. Apply remote changes to both the clone and the document.
	if len(pack.Snapshot) > 0 {
		d.clone = nil
		if err := d.doc.applySnapshot(pack.Snapshot, pack.Checkpoint.ServerSeq); err != nil {
			return err
		}
	} else {
		if err := d.ensureClone(); err != nil {
			return err
		}

		for _, c := range pack.Changes {
			if err := c.Execute(d.clone); err != nil {
				return err
			}
		}

		if err := d.doc.ApplyChanges(pack.Changes...); err != nil {
			return err
		}
	}

	// 02. Remove local changes applied to server.
	for d.HasLocalChanges() {
		c := d.doc.localChanges[0]
		if c.ClientSeq() > pack.Checkpoint.ClientSeq {
			break
		}
		d.doc.localChanges = d.doc.localChanges[1:]
	}

	// 03. Update the checkpoint.
	d.doc.checkpoint = d.doc.checkpoint.Forward(pack.Checkpoint)

	// 04. Do Garbage collection.
	d.GarbageCollect(pack.MinSyncedTicket)

	// 05. Update the status.
	if pack.IsRemoved {
		d.SetStatus(StatusRemoved)
	}

	return nil
}

// InternalDocument returns the internal document.
func (d *Document) InternalDocument() *InternalDocument {
	return d.doc
}

// Key returns the key of this document.
func (d *Document) Key() key.Key {
	return d.doc.key
}

// Checkpoint returns the checkpoint of this document.
func (d *Document) Checkpoint() change.Checkpoint {
	return d.doc.checkpoint
}

// HasLocalChanges returns whether this document has local changes or not.
func (d *Document) HasLocalChanges() bool {
	return d.doc.HasLocalChanges()
}

// Marshal returns the JSON encoding of this document.
func (d *Document) Marshal() string {
	return d.doc.Marshal()
}

// CreateChangePack creates pack of the local changes to send to the server.
func (d *Document) CreateChangePack() *change.Pack {
	return d.doc.CreateChangePack()
}

// SetActor sets actor into this document. This is also applied in the local
// changes the document has.
func (d *Document) SetActor(actor *time.ActorID) {
	d.doc.SetActor(actor)
}

// ActorID returns ID of the actor currently editing the document.
func (d *Document) ActorID() *time.ActorID {
	return d.doc.ActorID()
}

// SetStatus updates the status of this document.
func (d *Document) SetStatus(status StatusType) {
	d.doc.SetStatus(status)
}

// Status returns the status of this document.
func (d *Document) Status() StatusType {
	return d.doc.status
}

// IsAttached returns the whether this document is attached or not.
func (d *Document) IsAttached() bool {
	return d.doc.IsAttached()
}

// SetPresenceInfo sets the presence information of the given client.
func (d *Document) SetPresenceInfo(clientID string, info presence.Info) {
	d.doc.SetPresenceInfo(clientID, info)
}

// PresenceInfo returns the presence information of the given client.
func (d *Document) PresenceInfo(clientID string) (*presence.Info, error) {
	return d.doc.PresenceInfo(clientID)
}

// RemovePresenceInfo removes the presence information of the given client.
func (d *Document) RemovePresenceInfo(clientID string) {
	d.doc.RemovePresenceInfo(clientID)
}

// SetWatchedPeerMap sets the watched peer map.
func (d *Document) SetWatchedPeerMap(peerMap map[string]bool) {
	d.doc.SetWatchedPeerMap(peerMap)
}

// AddWatchedPeerMap adds the peer to the watched peer map.
func (d *Document) AddWatchedPeerMap(clientID string, hasPresence bool) {
	d.doc.AddWatchedPeerMap(clientID, hasPresence)
}

// RemoveWatchedPeerMap removes the peer from the watched peer map.
func (d *Document) RemoveWatchedPeerMap(clientID string) {
	d.doc.RemoveWatchedPeerMap(clientID)
}

// Presence returns the presence of the client who created this document.
func (d *Document) Presence() map[string]string {
	return d.doc.Presence()
}

// PeerPresence returns the presence of the given client.
func (d *Document) PeerPresence(clientID string) map[string]string {
	return d.doc.PeerPresence(clientID)
}

// PeersMap returns the list of peers, including the client who created this document.
func (d *Document) PeersMap() map[string]presence.Presence {
	return d.doc.PeersMap()
}

// RootObject returns the internal root object of this document.
func (d *Document) RootObject() *crdt.Object {
	return d.doc.RootObject()
}

// Root returns the root object of this document.
func (d *Document) Root() *json.Object {
	if err := d.ensureClone(); err != nil {
		panic(err)
	}

	ctx := change.NewContext(d.doc.changeID.Next(), "", d.clone)
	return json.NewObject(ctx, d.clone.Object())
}

// GarbageCollect purge elements that were removed before the given time.
func (d *Document) GarbageCollect(ticket *time.Ticket) int {
	if d.clone != nil {
		d.clone.GarbageCollect(ticket)
	}
	return d.doc.GarbageCollect(ticket)
}

// GarbageLen returns the count of removed elements.
func (d *Document) GarbageLen() int {
	return d.doc.GarbageLen()
}

func (d *Document) ensureClone() error {
	if d.clone == nil {
		copiedDoc, err := d.doc.root.DeepCopy()
		if err != nil {
			return err
		}
		d.clone = copiedDoc
	}
	return nil
}

func messageFromMsgAndArgs(msgAndArgs ...interface{}) string {
	if len(msgAndArgs) == 0 {
		return ""
	}
	if len(msgAndArgs) == 1 {
		msg := msgAndArgs[0]
		if msgAsStr, ok := msg.(string); ok {
			return msgAsStr
		}
		return fmt.Sprintf("%+v", msg)
	}
	if len(msgAndArgs) > 1 {
		return fmt.Sprintf(msgAndArgs[0].(string), msgAndArgs[1:]...)
	}
	return ""
}
